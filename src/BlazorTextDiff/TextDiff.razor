@using DiffPlex.DiffBuilder;
@using DiffPlex.DiffBuilder.Model;
@using DiffPlex;
@using DiffPlex.Chunkers;

<div class="@CssClass" @attributes="AdditionalAttributes">
   @if (Header is not null && diff is not null)
   {
      <div class="diff-header">
         @Header(new DiffStats(diff.OldText, diff.NewText))
      </div>
   }

   <CascadingValue Value="@CollapseContent" Name="@nameof(CollapseContent)">
      <div class="diff-panes"
           style="@(isCollapsed ? $"max-height: {MaxHeight}px; overflow: auto;" : "max-height: auto; overflow: auto;")">
         @if (diff is not null)
         {
            <div class="diff-pane">
               <TextDiffPane Model="diff.OldText"
                             PanePosition="@PanePosition.Left"
                             VisibleLines="@visibleLines"
                             OnShowHiddenLines="ShowHiddenLines" />
            </div>
            <div class="diff-pane">
               <TextDiffPane Model="diff.NewText"
                             PanePosition="@PanePosition.Right"
                             VisibleLines="@visibleLines"
                             OnShowHiddenLines="ShowHiddenLines" />
            </div>
         }
      </div>
   </CascadingValue>
   
   @if (CollapseContent)
   {
      <button type="button" class="diff-expand-notice" @onclick="ToggleCollapse">
         @(isCollapsed ? "▼ Show more" : "▲ Show less")
      </button>
   }
</div>

@code {
    /// <summary>
    /// When true, the diff algorithm will ignore case differences when comparing text.
    /// This affects the underlying diff calculation, not just display.
    /// </summary>
    [Parameter] public bool IgnoreCase { get; set; } = false;
    
    /// <summary>
    /// When true, the diff algorithm will ignore whitespace differences when comparing text.
    /// This affects the underlying diff calculation. Note: Visual whitespace highlighting
    /// is still shown for actual changes that are detected.
    /// </summary>
    [Parameter] public bool IgnoreWhiteSpace { get; set; } = false;
    
    [Parameter] public int MaxHeight { get; set; } = 300;
    [Parameter] public bool CollapseContent { get; set; }

    /// <summary>
    /// When true, unchanged lines will be hidden, showing only changed lines and some context.
    /// </summary>
    [Parameter] public bool HideUnchangedLines { get; set; } = false;

    /// <summary>
    /// The number of unchanged lines to show around each change when <see cref="HideUnchangedLines"/> is true.
    /// </summary>
    [Parameter] public int ContextLines { get; set; } = 3;

    /// <summary>
    /// The text before any changes.
    /// </summary>
    [Parameter] public string? OldText { get; set; }

    /// <summary>
    /// The text after any changes.
    /// </summary>
    [Parameter] public string? NewText { get; set; }
    
    [Parameter] public RenderFragment<DiffStats>? Header { get; set; }

    /// <summary>
    /// Additional CSS class(es) to apply to the root diff-container element.
    /// Useful for scoping custom style overrides to a specific instance.
    /// </summary>
    [Parameter] public string? Class { get; set; }

    /// <summary>
    /// Additional HTML attributes (style, id, data-*, etc.) to apply to the root element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private string CssClass => string.IsNullOrWhiteSpace(Class) ? "diff-container" : $"diff-container {Class}";

    private SideBySideDiffModel? diff;
    private bool isCollapsed;
    private bool[]? visibleLines;

   /// <summary>
   /// When parameters set update the component.
   /// </summary>
   protected override void OnParametersSet()
   {
      isCollapsed = CollapseContent;

      if (!string.IsNullOrEmpty(OldText) || !string.IsNullOrEmpty(NewText))
      {
         // Always use CharacterChunker for precise per-character highlighting.
         // ignoreWhiteSpace is NOT passed to DiffPlex because CharacterChunker
         // treats each space as a distinct character and the flag can't suppress
         // those diffs. Instead we post-process to remove whitespace-only changes.
         diff = SideBySideDiffBuilder.Diff(
            new Differ(),
            OldText ?? string.Empty,
            NewText ?? string.Empty,
            false,
            IgnoreCase,
            LineChunker.Instance,
            CharacterChunker.Instance);

         if (IgnoreWhiteSpace)
         {
            DowngradeWhitespaceOnlyChanges(diff.OldText);
            DowngradeWhitespaceOnlyChanges(diff.NewText);
         }
      }
   }

    /// <summary> Creates a visibility state array for each line based on diff changes </summary>
    private void CalculateVisibility()
    {
       if (diff == null || !HideUnchangedLines)
       {
          visibleLines = null;
          return;
       }

       var lineCount = diff.OldText.Lines.Count;
       visibleLines = new bool[lineCount];

       for (var i = 0; i < lineCount; i++)
       {
          var oldLineUnchanged = diff.OldText.Lines[i].Type == ChangeType.Unchanged;
          var newLineUnchanged = diff.NewText.Lines[i].Type == ChangeType.Unchanged;

          if (oldLineUnchanged && newLineUnchanged)
             continue;

          var contextLinesStart = Math.Max(0, i    - ContextLines);
          var contextLinesEnd = Math.Min(lineCount - 1, i + ContextLines);

         for (var j = contextLinesStart; j <= contextLinesEnd; j++)
         {
            visibleLines[j] = true;
         }
      }
   }

   /// <summary>
   /// For lines whose only sub-piece changes are whitespace characters,
   /// downgrade them to Unchanged so they don't show as modified.
   /// Lines with any non-whitespace character changes keep full highlighting.
   /// </summary>
   private static void DowngradeWhitespaceOnlyChanges(DiffPaneModel pane)
   {
      foreach (var line in pane.Lines)
      {
         if (line.Type is not (ChangeType.Modified or ChangeType.Inserted or ChangeType.Deleted))
            continue;
         if (line.SubPieces is null || line.SubPieces.Count == 0)
            continue;

         bool hasNonWhitespaceChange = false;
         foreach (var sub in line.SubPieces)
         {
            if (sub.Type != ChangeType.Unchanged && sub.Type != ChangeType.Imaginary
                && !string.IsNullOrEmpty(sub.Text) && !sub.Text.All(char.IsWhiteSpace))
            {
               hasNonWhitespaceChange = true;
               break;
            }
         }

         if (!hasNonWhitespaceChange)
         {
            line.Type = ChangeType.Unchanged;
            line.SubPieces.Clear();
         }
      }
   }

   private void ToggleCollapse()
   {
      isCollapsed = !isCollapsed;
   }

   private void ShowHiddenLines((int Start, int Count) range)
   {
       if (visibleLines == null)
          return;

       var rangeEnd = Math.Min(range.Start + range.Count, visibleLines.Length);
       for (var i = range.Start; i < rangeEnd; i++)
       {
          visibleLines[i] = true;
       }

       StateHasChanged();
   }
}
